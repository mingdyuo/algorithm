### Problem Solving

#### Baekjoon Online Judge

- [ ] 16637 괄호 추가하기 

> 20.12.29 **실패**
>
> 사용한 자료구조는 deque이며, 생각했던 알고리즘은 다음과 같다.
>
> 1. 숫자, '*'는 순서에 그냥 삽입
>
> 2. '+'의 경우
>
>    2-1. 만약 직전에 괄호로 묶지 않았으며, 직전이 '-'가 아니라면
>
>    ​		해당 연산을 미리 계산하여 순서에 삽입.
>
>    2-2. 직전에 괄호로 묶었거나 직전이 '-'라면
>
>    ​		그냥 순서에 삽입
>
> 3. '-'의 경우'
>
>    3-1. 만약 직전에 괄호로 묶지 않았으며, 직전이 '-'라면
>
>    ​		해당 연산을 미리 계산하여 순서에 삽입.
>
>    3-2. 만약 직전에 괄호로 묶었거나, 직전이 '-'가 아니라면
>
>    ​		그냥 순서에 삽입
>
> 그러나 이 알고리즘을 따르면 6번 예제인 `1-9-1-9-1-9-1-9-1-9`에서 `9-1`만을 묶기 때문에 최대값을 구할 수 없게 된다. 이 경우에서 `1-9`부터 묶기 위해서는 미래를 미리 계산하거나, 해당 차이가 음수 혹은 양수인지를 고려하는 등 다른 알고리즘이 필요한 것 같은데 떠오르지 않았다.
>
> ---
>
> 💬 
>
> 문제를 풀 때 항상 input size를 보자. **input size가 감당 가능하면 무조건 brute force로 계산하자.** 이 문제의 경우에는, 들어오는 수식의 길이가 최대 19이고, 연산자 개수는 9개이다. 따라서 묶거나/안묶거나를 기준으로 모든 경우의 수를 구해도 아주 충분한 시간, 공간복잡도를 갖는다. 
>
> 근데 이 문제는 brute force로 결정해도 연산 처리 구현이 약간 까다로운 것 같다. 
>
> 검색해보면 DFS라고 하긴 하는데 사실상 모든 경우를 다 봐서 그냥 brute force로 처리함
>
> [참고 소스](https://11001.tistory.com/16)

- [ ] 124 나라의 숫자

> 20.12.30 **성공**
>
> 💬 
>
> <u>0인 경우 1을 추가, 1인 경우 2를 추가, 2인 경우 4을 추가</u>하는 경우
>
> → `char arr[] = {'1', '2', '4'};`를 만들고  `arr[modulo]`를 해주면 조건문 사용하지 않고 바로 삽입할 수 있다.

- [ ] 주식 가격

> 21.01.05 (정확도 테스트 성공, **효율성 테스트 실패**)
>
> 사용한 자료 구조는 deque, multiset, 배열이다. 
>
> deque은 자료를 앞으로 삽입한 후 벡터에 옮기기 위해 사용, multiset은 나온 가격 값들을 빠르게 저장하되, 작은 값부터 빠르게 접근하기 위해서 사용, 배열은 해당 가격에 대해 가장 최근에 나온 인덱스를 저장했다.
>
> 생각했던 알고리즘은 다음과 같다.
>
> ```
> multiset, array에 가장 마지막 원소 저장
> for(마지막 원소부터 맨 앞 원소까지){
> 	multiset에서 현재보다 작은 원소 찾고, 
> 	찾은 원소에 대해 가장 가까운 인덱스 찾는다.
> 	if(위에서 찾았다면)
> 		deque에 거리 집어넣음
> 	else
> 		deque에 맨 뒤부터의 거리 넣음
> 	현재 정보 multiset과 배열에 넣음
> } 
> ```
> 내 생각에는 multiset에서 현재보다 작은 원소 찾는게 set을 다 도는 것보다는 시간이 단축되었다지만, 큰 수의 경우에는 원소의 개수만큼 돌기 때문에 여기서 시간이 많이 드는게 아닌가 싶다.
>
> 💬 
>
> 빠를 것 같은 자료구조로 난리난리를 쳤는데 알고보니 그냥 이중 포문으로 풀 수 있는 문제였다 ;; 허무하군,,
>
> 그리고 스택으로도 푸는 방법이 있다. 이건 생각도 못했다
>
> 

