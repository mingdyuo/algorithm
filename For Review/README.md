### Problem Solving

#### Baekjoon Online Judge

- [ ] **16637 괄호 추가하기** 

> 20.12.29 **실패**
>
> 사용한 자료구조는 deque이며, 생각했던 알고리즘은 다음과 같다.
>
> 1. 숫자, '*'는 순서에 그냥 삽입
>
> 2. '+'의 경우
>
>    2-1. 만약 직전에 괄호로 묶지 않았으며, 직전이 '-'가 아니라면
>
>    ​		해당 연산을 미리 계산하여 순서에 삽입.
>
>    2-2. 직전에 괄호로 묶었거나 직전이 '-'라면
>
>    ​		그냥 순서에 삽입
>
> 3. '-'의 경우'
>
>    3-1. 만약 직전에 괄호로 묶지 않았으며, 직전이 '-'라면
>
>    ​		해당 연산을 미리 계산하여 순서에 삽입.
>
>    3-2. 만약 직전에 괄호로 묶었거나, 직전이 '-'가 아니라면
>
>    ​		그냥 순서에 삽입
>
> 그러나 이 알고리즘을 따르면 6번 예제인 `1-9-1-9-1-9-1-9-1-9`에서 `9-1`만을 묶기 때문에 최대값을 구할 수 없게 된다. 이 경우에서 `1-9`부터 묶기 위해서는 미래를 미리 계산하거나, 해당 차이가 음수 혹은 양수인지를 고려하는 등 다른 알고리즘이 필요한 것 같은데 떠오르지 않았다.
>
> ---
>
> 💬 
>
> 문제를 풀 때 항상 input size를 보자. **input size가 감당 가능하면 무조건 brute force로 계산하자.** 이 문제의 경우에는, 들어오는 수식의 길이가 최대 19이고, 연산자 개수는 9개이다. 따라서 묶거나/안묶거나를 기준으로 모든 경우의 수를 구해도 아주 충분한 시간, 공간복잡도를 갖는다. 
>
> 근데 이 문제는 brute force로 결정해도 연산 처리 구현이 약간 까다로운 것 같다. 
>
> 검색해보면 DFS라고 하긴 하는데 사실상 모든 경우를 다 봐서 그냥 brute force로 처리함
>
> [참고 소스](https://11001.tistory.com/16)

- [ ] **124 나라의 숫자**

> 20.12.30 **성공**
>
> 💬 
>
> <u>0인 경우 1을 추가, 1인 경우 2를 추가, 2인 경우 4을 추가</u>하는 경우
>
> → `char arr[] = {'1', '2', '4'};`를 만들고  `arr[modulo]`를 해주면 조건문 사용하지 않고 바로 삽입할 수 있다.

- [ ] **주식 가격**

> 21.01.05 (정확도 테스트 성공, **효율성 테스트 실패**)
>
> 사용한 자료 구조는 deque, multiset, 배열이다. 
>
> deque은 자료를 앞으로 삽입한 후 벡터에 옮기기 위해 사용, multiset은 나온 가격 값들을 빠르게 저장하되, 작은 값부터 빠르게 접근하기 위해서 사용, 배열은 해당 가격에 대해 가장 최근에 나온 인덱스를 저장했다.
>
> 생각했던 알고리즘은 다음과 같다.
>
> ```c++
> multiset, array에 가장 마지막 원소 저장
> for(마지막 원소부터 맨 앞 원소까지){
> 	multiset에서 현재보다 작은 원소 찾고, 
> 	찾은 원소에 대해 가장 가까운 인덱스 찾는다.
> 	if(위에서 찾았다면)
> 		deque에 거리 집어넣음
> 	else
> 		deque에 맨 뒤부터의 거리 넣음
> 	현재 정보 multiset과 배열에 넣음
> } 
> ```
> 내 생각에는 multiset에서 현재보다 작은 원소 찾는게 set을 다 도는 것보다는 시간이 단축되었다지만, 큰 수의 경우에는 원소의 개수만큼 돌기 때문에 여기서 시간이 많이 드는게 아닌가 싶다.
>
> 💬 
>
> 빠를 것 같은 자료구조로 난리난리를 쳤는데 알고보니 그냥 이중 포문으로 풀 수 있는 문제였다 ;; 허무하군,,
>
> 그리고 스택으로도 푸는 방법이 있다. 이건 생각도 못했다
>
> 

- [ ] **소수 찾기 (programmers level 2)**

> 21.01.07 **실패**
>
> 40분 잡고 풀었는데 일단 코드까지 어떻게 쓰긴 했지만, 제대로 안돌아가는 것 같다.
>
> 생각한 알고리즘은 다음과 같다.
>
> 1. 1 ~ 10^(number의 개수) 까지 소수여부를 배열에 미리 계산해 놓는다. (에라토스테네스의 채 사용)
>
> 2. 재귀 함수를 이용하여, 입력된 제한 크기까지 숫자 조합을 만든다.
>
>    제한 크기는 1 ~ number의 개수이다.
>
> 3. 만들어진 숫자 조합에서 next_permutation을 이용해 모든 순서를 생성해보고, 해당 순서로 만들어진 숫자가 소수인지 판단.
>
> 💬 
>
> [이 블로그](https://intaehwang.tistory.com/11)의 풀이를 보면 다음과 같이 풀이하였다.
>
> > 1. permutation을 이용하여 모든 경우를 구한다
> > 2. vector의 erase와 unique를 이용하여 중복된 vector 값을 제외한다.
> > 3. 주어진 vector 값의 소수 여부를 확인한다.
>
> 여기서 주안점은 숫자의 개수가 최대 7개 주어지기 때문에 7! = 5040이라는 적은 숫자이므로 permutation으로 죄다 돌면서 경우가 되는 ''숫자''만 미리 구해 놓는 것이다.  
> (나는 permutation을 썼지만 input size에 대해서는 깊게 생각을 안했다. 괄호 추가하기에서 했던 것과 같은 실수를 했다. 반성 또 반성)
>
> 그 다음에 중복되는 값을 제거하고 
> (이 기법도 알기는 하지만 익숙하지 않으므로 잘 외워놓아야겠다.)
>
> ``` c++
> sort(v.begin(), v.end());
> v.erase(unique(v.begin(), v.end()), v.end());
> ```
>
> 그 다음에 벡터에 있는 모든 값에 대해 소수인지 아닌지 확인한 것이다. 
> (굳이 숫자 사이즈 내의 모든 값을 다 소수판별 해놓을 필요가 전혀 없었다. 차라리 그때 그때 소수인지 확인해도 문제가 없었다. 왜냐면 사이즈가 작기 때문이지!!!!!! 좀 헛짓거리 줄이고 코테는 코테처럼 플젝은 플젝처럼 잘 해야할텐데...)

- [ ] **가장 큰 수**

> 21.01.07 **실패**
>
> 시간 오래 썼는데도 내가 원하는 대로 작동을 안한다. 
> 연이은 실패에 좌절감이 들지만,,,, 그냥 하루하루 배우는걸 목표로 삼아야지!!!! 
>
> 처음 생각한 알고리즘은 vector에 숫자를 문자열로 넣은 후 정렬을 하는데, 정렬함수 내의 알고리즘은 다음과 같이 썼다.
>
> 1. 작은 크기의 문자열 길이 기준으로 먼저 비교를 하고 사전식으로 리턴
> 2. 만약 작은 크기 문자열에서 글자가 다 같다면, 큰 크기 문자열의 바로 다음 글자와 맨 앞 글자를 비교한다. 
>
> 💬 
>
> 뭔가 알겠긴한데 안풀리는 이상한 빡치는 문제였다 
>
> string의 >, < 비교는 사전순으로 되며, 0이 맨 앞에 있는 경우에는 모든 수가 0이라는 뜻이므로 0 하나만 반환해야 한다. 

- [ ] **큰 수 만들기**

> 21.01.08 **실패**
>
> 그리디 문제 발상이 너무 어렵다 날잡아서 그리디 문제만 조져야겠다. 이번 문제에서는 number의 개수가 최대 1,000,000자리이기 때문에 완전탐색하면 시간 터질 것이 농후하다. 사실 문제 분류에서 그리디라고 힌트를 줬는데, 계속 고민해도 모르겠어가지고 포기했다.
>
> 내가 처음에 생각한 알고리즘은 다음과 같다.
>
> 1. 주어진 숫자 내에서 가장 작은 숫자 k개를 뽑아낸다. (중복 허용)
> 2. 숫자 맨 앞에서부터 시작해서 해당 숫자가 가장 작은 숫자내에 있으면 패스, 없으면 넣는다.
>
> 그런데 이렇게 하면 앞에 있는 숫자가 작은숫자에 포함되지 않는데, 큰 배열을 만들지도 않는 경우 망한다. 
>
> 💬 
>
> 앞에서부터 가장 큰 값을 찾는데, 이 때 왜 i+k까지인지 아직 이해가 잘 안된다
>
> [스택으로 푸는 풀이](https://devje8.tistory.com/4)도 있는데 좋은 발상인 것 같다.

- [ ] **조이 스틱**

> 21.01.09 **성공**
>
> 다른 사람의 코드를 구경하다가 내가 생각했던 원리와 같지만 훨씬 간결하게 표현한 코드가 있어 기록하려 한다.
>
> 목적은 무엇이냐면 name이라는 string 안에서 가장 긴 연속되는 'A' 길이에 대해 움직임 횟수를 찾는 것이다. 나는 이전 글자를 저장하고 다음 글자에서 매번 조건문을 확인하여 'A'의 개수를 확인 및 인덱스를 저장하였다. 그리고 반복문을 모두 돈 후 'A' 최대 배열 인덱스에 대한 최소 움직임 횟수를 구하였다. 근데 이 코드는, 'A' 배열을 한번에 찾고 거기서 바로 움직임 최소 횟수를 구해서 갱신하는 것이다. 
>
> <u>*나의 코드*</u>
>
> ```c++
> // 목적 : 전부 다 돌면서 최대 A 연속배열을 다 구한 후 최소 움직임 횟수 찾기
> int aCount = 0, aMaxCount = 0;
> char prev = name[0];
> int maxA[2];
> vector<int> Aindex;
> if (prev == 'A') {
>     aCount++;
>     Aindex.push_back(0);
> }
> for (int i = 1; i < name.size(); i++) {
>     if (prev == 'A') {
>         if (name[i] == 'A') {
>             aCount++;
>             Aindex.push_back(i);
>         }
>         else {
>             if (aMaxCount < aCount) {
>                 aMaxCount = aCount;
>                 maxA[0] = Aindex.front();
>                 maxA[1] = Aindex.back();
>             }
>             aCount = 0;
>             Aindex.clear();
>         }
>     }
>     else {
>         if (name[i] == 'A') {
>             aCount = 1;
>             Aindex.push_back(i);
>         }
>     }
>     prev = name[i];
> }
> if (prev == 'A' && aMaxCount < aCount) {
>     aMaxCount = aCount;
>     maxA[0] = Aindex.front();
>     maxA[1] = Aindex.back();
> }
> int backwards = name.size() - maxA[1] + 2 * maxA[0] - 3,
>     forwards = name.size() - 1;
> answer += forwards < backwards ? forwards : backwards;
> ```
>
> <u>*훨씬 간결한 코드*</u>
>
> ```c++
> int len = name.length();
> int left_right = len - 1;
> for (int i = 0; i < len; ++i) {
>    int next_i = i + 1;
>    while (next_i < len && name[next_i] == 'A') // 'A'연속 배열 한번에 구하기
>        next_i++;
>    left_right = min(left_right, i + len - next_i + min(i, len - next_i));
>     // 최소 움직임 횟수 구하기
> }
> ```
>
> 움직임 최소 횟수를 구하는 코드가 처음에는 이해가 잘 안됬다.
>
> ` i + len - next_i + min(i, len - next_i)` 
>
> 근데 왼쪽 들렸다 오는게 아니라 오른쪽 왕복을 하고 왼쪽은 편도로 가는게 빠른 경우도 있겠구나 라는 것을 깨달음 🤦🏻‍♀️

- [ ] **H-index**

> 21.01.09 **성공**
>
> 조금 더 디테일하게 값을 따져서 수식을 세우지 않아서 좀 시간 낭비를 했다.
>
> 인용 횟수를 정렬한 후, 인용 횟수보다 해당 인용 횟수 이상의 편수가 작거나 같으면 탈출하도록 조건을 짰는데, 작은 경우에 따져야 할 것이 추가로 있었다. 다시 말해서 인용 횟수가 해당 인용 횟수 이상의 편수보다 작거나 같을때는 단순히 그 직전 인용 횟수나 해당 편수가 답이 되는 것이 아니라, 그 두 값의 최댓값이 답이 되는 것이었다. 코드로 보면 이렇다.
>
> ```c++
> sort(citations.begin(), citations.end());
> for (int i = 0; i < citations.size(); i++) {
>     if (citations[i] == citations.size() - i) {
>         answer = citations[i]; break;
>     }
>     else if (citations[i] > citations.size() - i) {
>         answer = max(citations[i - 1], (int)citations.size() - i);
>         // 이 부분에서 두 값의 최대값을 구해야 했다.
>         break;
>     }
> }
> ```
>

- [ ] **위장**

> 21.01.09 
>
> 재귀를 구현하는게 좀 뻑뻑해졌다 다시 옛날에 풀어봤던 것들 좀 찾아서 익숙해져야겠다.

- [ ] **7579 앱**

> 21.01.13 **실패**
>
> 11053 가장 긴 증가하는 부분 수열 문제와 유사한 논리로 풀어보았다. 그런데 99%에서 틀려서 논리가 틀린 것은 아닌 것 같지만 엣지 케이스를 찾을 수 없어서 다시 구상을 했다.
>
> 문제 정의까지는 된 것 같은데 ("M 바이트 확보를 위해 필요한 앱 활성화의 최소 비용") DP 문제 쪼개기 발상이 잘 안된당. cost 낮은 순으로 해야 할지, 용량 대비 cost 낮은 순으로 해야 할 지 용량 큰 순으로 정렬해야 할지 모르겠고, 그 다음에 관계식을 어떻게 세울 지 잘 감이 안온당. 
>
> 냅색 스타일인가 했는데, M의 값이 너무 커서 배열을 만드는게 쉽지 않을 것 같고, 넣거나/안넣거나로 모든 원소를 돌게 되면 2^N이 되어 버려서 안된당.
>
> 💬 
>
> 찾아보니 냅색 스타일 문제는 맞는데, M을 이용해서 배열을 만드는게 아니라 cost 를 이용해서 배열을 만드는 거였다.
>
> 메모리는 초과를 해도되고 안해도 되기 때문에 메모리 기준으로 비용을 잡는 것이 아니라, 비용 기준으로 메모리를 잡는 것이 좋은듯. 그리고 다시 보니까 그냥 문제 자체를 정의로 잡았구나.
>
> 배열을 뒤에서부터 채워서 되는 것도 헷갈리고 그냥 문제를 많이 풀어서 이 감각을 익혀야 겠다 ㅠㅠㅠㅠ

- [ ] **2878 캔디캔디**

> 21.01.18 **실패**
>
> 그리디 너무 발상이 어렵다. "뭐랄까 숫자를 이렇게 깎고 대충 차이를 최소화 시키면 될 것 같은데" 그걸 수식으로 구현하고 풀어내고 그 정당성을 증명하는 게 너무 어렵다.
>
> 이 문제도 정렬하고, 주어진 사탕 개수를 요래조래 빼는것까지는 생각했는데, 처음에는 pivot을 차례 차례 잡고 그 앞에 있는 애들을 다 가지치기 하듯이 깎아주도록 풀었다. 근데 이 문제는 O(N^2) 나오니까 안되고, 그리디로 풀려면 분명히 앞에서부터 차례차례 딱딱 쳐내서 O(N)가 나와야 할 테고, 그러려면 미리 어떤 정보가 필요할 텐데 그거는 뭔가 현재 요구 사탕의 총합과 가용한 사탕의 개수가 될 것 같았다. 그치만 결국 그걸 구하는 방법은 생각하지 못했다. 
>
> 💬 
>
> 작은 순으로 정렬하고, 못주는 사탕을 분배하되, 최대한 평평하게 분배한것과 요구하는 사탕의 개수를 비교해서 작은 애를 선택하도록 만들면 풀리는 문제였다.

- [ ] **10775 공항**

> 21.01.18 **실패**
>
> 일단 매 공항마다 가능한 게이트를 돌게 되면 시간초과가 난다. 띠용 그냥 2878번 문제처럼 푸는 건 줄 알았는데 유니온 파인드 자료구조를 쓰는 문제다. 문제를 계속 선형적으로만 인식하고 있었는데 그래프의 관점에서 푸는 연습도 중요한 것 같다.
>
> 유니온 파인드, 우선순위 큐 등의 ''자료구조''는 단독으로 쓰이는 문제가 별로 없지만, 어떤 알고리즘을 구현하기 위해 필수적으로 써야 하는 기반이 된다. 자료구조의 본질은 어떤 작업을 효율적으로 처리하기 위해 존재하는 것이다. 이를 잘 기억해두자.

- [ ] **11085 군사 이동**

> 21.01.21 **실패**
>
> 일단 처음에 문제 이해를 잘못했다. *"경로 상에 있는 길 중 너비가 가장 좁은 길의 너비를 최대화하는 경로를 택했습니다."*라는 말이 당최 무슨 말인가 했더니 시작 위치에서 도착 위치로 가는 경로가 여러개 있을 텐데, 그 경로에 있는 각자의 최소 너비가 가장 큰 경로의 최소 너비를 찾는 것이다. 
>
> 코드는 마치 다익스트라처럼 생겼으나 약간 다른데, 어떤 점에서 다르냐면, 정점을 하나 뽑고 다음 경로로 갈 때 최솟값을 계속 가지고 간다. 그런데, priority queue를 사용했으므로 그 중에서 작은건 나중에 뽑힌다. 

- [ ] **11995 Fenced In**

> 21.01.26 **실패**
>
> 0 <= n,m <= 2000 이라서 최대 생성되는 방의 개수가 2001 * 2001 = 4004001개이기 때문에 MST로 전체 방을 순회해도 괜찮을 것이라고 생각했다. 그런데 시간 초과가 났다 ㅠㅠ
>
> > 검색해서 보니 크루스칼로 접근 시 시간 복잡도는 좌우상하(*4)에다가 힙에 추가하는 비용까지 추가해서 O(4NMlog(4NM)) (3e8정도)라고 한다.
> >
> > 나는 프림 알고리즘을 썼는데, 방문한 노드는 미리 확인해서  건너가므로 조금은 더 적지 않을까 싶다. 하지만 아무튼 시간을 줄이려고 노력해도 알고리즘 자체를 바꾸지 않는 한 찔끔씩 밖에 줄어들지 않을 것이다.
>
> 시간 초과가 난 후에 다시 본건, 각 행과 행 사이, 열과 열 사이의 cost가 동일하기 때문에, 무언가 다른 방법으로 풀 수 있을 것 같은데, 규칙이 생각이 나지 않았다. 일단 가장 최소의 벽은 무조건 부시고 시작하는 것 같은데 거기서 MST를 시작하면 또 전체 정점을 모두 순회하기 때문에 똑같음
>
> 풀이는 다음과 같다고 한다.
>
> 1. y방향 길이와 x방향 길이를 정렬
> 2. 병합정렬(Merge Sort)하듯이 둘을 적당히 돌아가며 작은 간선을 찾아, **해당하는 정점들을 Union**
>

- [ ] **14604 샤워실 바닥 깔기**

> 21.01.26 **실패**
>
> 전혀 감이 안잡혀서 빠르게 접은 문제 ㅎㅎ; 그래도 접기 전에 뭘 모르겠는지는 정리 해놓고 답을 찾아보자
>
> 1. 재귀를 한다면, 초기 조건 설정을 어떻게 하는걸까
> 2. 뭘 분할하고 어떻게 merge 할지 감이 안옴 (4 * 4, 8 * 8 단위로 쪼개서 도장찍듯이 하는게 불가능함. 다 얼기설기 엮여서 타일을 채워야 함) 
> 3. 구현문제. ㄱ자 타일로 마구잡이로 채워야 하는지 어째야 하는지 잘 모르겠음. 변수 하나 잡고 증가시키면서 채우면 되겠긴 하지만 세부 구현 방법이 감이 안온다. 테트리스처럼 ㄱ자 모양을 모든 방향으로 만들어 놓고 채워야 하는 건가
>
> 💬 
>
> 트로미노 타일링이라는 유명한 문제라고 한다. 
>
> [참고1](https://dongwoo338.tistory.com/6)
>
> [참고2](https://www.youtube.com/watch?v=BFjJxA5Ym_U&ab_channel=%EC%A3%BC%EB%8B%88%EC%98%A8TV%EC%95%84%EB%AC%B4%EA%B1%B0%EB%82%98%EC%97%B0%EA%B5%AC%EC%86%8C)
>
> [참고3](https://casterian.net/archives/171)
>
> 풀이를 찾아보고 D&C의 원리는 대강 이해했는데, 이걸 코드 수준에서 인덱스 생각하면서 구현하라고 하면 머리 하얘질듯 ㅇㅇ; 연습해야겠다

- [ ] **8983 사냥꾼**

> 21.01.23 **실패**
>
> 스터디때 같이 풀었던 문제다. ㅎㄹ 이분탐색하는 문젠데!!!!!!!!!!!! 와 이 생각을 왜 못했지
>
> 일단 사대 정렬하고 동물 좌표 들어오면 탐색 시작하는 건 똑같다. 나는 동물 하나당 x 좌표의 lower bound부터 upper bound까지 돌면서 `|사대 - x좌표| + y 좌표 <= 범위`를 매번 검사했당. 근데 저걸 아예 탐색 과정에 조건문으로 넣어주면 훨씬 빠르게 가능함 다시말해서 이분탐색 반복문에서 `x좌표 + y좌표 - 범위 <= 사대`이거나 `사대 <= 범위 + x좌표 - y좌표`인지를 검사해주면 된다는 말이다. 수식을 이렇게 바꿔서 동물 하나당 쓸데없는 탐색을 줄일 수가 있다.

- [ ] **단체사진 찍기**

> 21.02.05 **실패**
>
> 와 이거 어떻게 풀지 엄청 고민하고, 조건에 맞춰서 어떻게 가능한 배열을 찾지 생각했는데, 그냥 next_permutation으로 쫙 돌면서 조건 하나라도 안맞으면 빠져나오는 식으로 푸는 거였다.
>
> 8!을 생각을 왜 안해봤지... 8! 별로 안큰데 왜 이거 다 못돌거라고 생각했지?! 

- [ ] **1062 가르침**

> 21.02.09 **실패**
>
> 문자열 조작 문제인 줄 알았는데 브루트 포스 백트래킹 문제였다 (!!)
>
> 일단 생각하지 못했던 지점
>
> 1. 알파벳은 종류가 한정되어 있으므로 배열에 넣어서 있다 없다 체크하면 되는데 set에 넣어서 계속 찾았다는 점
> 2. 약간 아무 생각 없이 그리디 처럼 풀었음
> 3. 처음에 주어지는 K 값에 대해 5미만이거나 26이상인 경우 처리를 생각하지 못함
>
> 그리고 주안점은 단어에 대해 글자을 모으는 것이 아니라, **글자를 조합한 후 그에 대해 단어가 가능한지 확인해야 한다는 것**이었다. 26CK-5이긴 한데 백트래킹 기법을 사용하므로 연산 시간을 단축시킬 수 있다.

- [ ] **9251 LCS**

> 21.02.09 **실패**
>
> DP로 편집거리 푸는 것과 분명 매커니즘은 비슷할 것 같은데, 값을 갱신하는 알고리즘을 잘못 선택했다.
>
> 같은 문자가 나왔을 때 왼쪽, 오른쪽, 대각선 값을 모두 찾아서 거기의 min 값에 1을 더했는데 대각선만 선택해야 했었다! 안그러면 계속 같은 문자가 붙을 때마다 LCS는 증가하지 않지만 값이 증가한다 (...)

- [ ] **9935 문자열 폭발**

> 21.02.27 **실패**
>
> `find`, `erase` 함수 돌리다가 시간초과 눈탱이 맞아버렸다.. 
>
> string이 능사가 아니라는 것을 알았닼ㅋㅋㅋㅋ 처음부터 쭉 읽으면서 폭탄 문자열 발견하면 없애고, 이런 식으로 하려고 했지만 char을 안쓰고 string을 계속 자르고 붙여서 결국 `O(N^2)`정도의 반복문이 생긴다.
>
> char 배열을 사용하고, 폭탄 문자의 마지막 글자가 일치할 때마다 폭탄이 들어왔는지 확인해주면서 (폭탄이 여러겹 존재할 수 있으므로 마지막 문자를 확인) index를 줄이고 덮어 씌워주면 `O(N)`에 해결이 가능하다.
>
> [여기](https://jaimemin.tistory.com/823)를 참고했다.

- [ ] **2887 행성 터널**

> 21.02.27 **실패**
>
> 뭔가 그래프, MST 이런거랑 관련이 있다는 것은 알겠지만, 도저히 가장 짧은 간선을 어떻게 잡아올지 감이 안왔다. 모든 행성간의 간선을 다 담아놓고 비교하는건 시간과 공간 모두 복잡도가 O(N^2)으로 말도 안되기 때문에 걍 시도를 안했다. 
>
> 💬 
>
> [여기](https://chanhuiseok.github.io/posts/baek-34/)를 참고하며 공부했다.
>
> 크루스칼을 쓰는게 맞는데, 역시나 **문제에서 간선의 가중치가 되는 값**을 찾는 것이 핵심이라고 한다. 행성간에는 x, y, z 좌표의 차이값이 가장 작은 값들이 간선 가중치 후보가 될 수 있다. 
>
> 비용이 `min(|xA-xB|, |yA-yB|, |zA-zB|)` 라는게 겁나 핵심이다. 나는 x, y, z 좌표를 모두 연관지어서 (마치 유클리디안 거리로 착각) 생각했었는데, 그럴 필요가 전혀 없었다! **문제를 제발 착각하지 말자** 아무튼 그래서 x, y, z를 한번에 담을 필요가 없고 따로 저장해도 된다. 그리고 필요한 값은 **가까이 있는 애들의 좌표 차이값**이다. wow
>
> 이제 union find 를 사용해서 cycle을 판별하며 크루스칼을 만들어나가면 된다.

