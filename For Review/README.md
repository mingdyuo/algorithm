### Problem Solving

#### Baekjoon Online Judge

- [ ] **16637 괄호 추가하기** 

> 20.12.29 **실패**
>
> 사용한 자료구조는 deque이며, 생각했던 알고리즘은 다음과 같다.
>
> 1. 숫자, '*'는 순서에 그냥 삽입
>
> 2. '+'의 경우
>
>    2-1. 만약 직전에 괄호로 묶지 않았으며, 직전이 '-'가 아니라면
>
>    ​		해당 연산을 미리 계산하여 순서에 삽입.
>
>    2-2. 직전에 괄호로 묶었거나 직전이 '-'라면
>
>    ​		그냥 순서에 삽입
>
> 3. '-'의 경우'
>
>    3-1. 만약 직전에 괄호로 묶지 않았으며, 직전이 '-'라면
>
>    ​		해당 연산을 미리 계산하여 순서에 삽입.
>
>    3-2. 만약 직전에 괄호로 묶었거나, 직전이 '-'가 아니라면
>
>    ​		그냥 순서에 삽입
>
> 그러나 이 알고리즘을 따르면 6번 예제인 `1-9-1-9-1-9-1-9-1-9`에서 `9-1`만을 묶기 때문에 최대값을 구할 수 없게 된다. 이 경우에서 `1-9`부터 묶기 위해서는 미래를 미리 계산하거나, 해당 차이가 음수 혹은 양수인지를 고려하는 등 다른 알고리즘이 필요한 것 같은데 떠오르지 않았다.
>
> ---
>
> 💬 
>
> 문제를 풀 때 항상 input size를 보자. **input size가 감당 가능하면 무조건 brute force로 계산하자.** 이 문제의 경우에는, 들어오는 수식의 길이가 최대 19이고, 연산자 개수는 9개이다. 따라서 묶거나/안묶거나를 기준으로 모든 경우의 수를 구해도 아주 충분한 시간, 공간복잡도를 갖는다. 
>
> 근데 이 문제는 brute force로 결정해도 연산 처리 구현이 약간 까다로운 것 같다. 
>
> 검색해보면 DFS라고 하긴 하는데 사실상 모든 경우를 다 봐서 그냥 brute force로 처리함
>
> [참고 소스](https://11001.tistory.com/16)

- [ ] **124 나라의 숫자**

> 20.12.30 **성공**
>
> 💬 
>
> <u>0인 경우 1을 추가, 1인 경우 2를 추가, 2인 경우 4을 추가</u>하는 경우
>
> → `char arr[] = {'1', '2', '4'};`를 만들고  `arr[modulo]`를 해주면 조건문 사용하지 않고 바로 삽입할 수 있다.

- [ ] **주식 가격**

> 21.01.05 (정확도 테스트 성공, **효율성 테스트 실패**)
>
> 사용한 자료 구조는 deque, multiset, 배열이다. 
>
> deque은 자료를 앞으로 삽입한 후 벡터에 옮기기 위해 사용, multiset은 나온 가격 값들을 빠르게 저장하되, 작은 값부터 빠르게 접근하기 위해서 사용, 배열은 해당 가격에 대해 가장 최근에 나온 인덱스를 저장했다.
>
> 생각했던 알고리즘은 다음과 같다.
>
> ```c++
> multiset, array에 가장 마지막 원소 저장
> for(마지막 원소부터 맨 앞 원소까지){
> 	multiset에서 현재보다 작은 원소 찾고, 
> 	찾은 원소에 대해 가장 가까운 인덱스 찾는다.
> 	if(위에서 찾았다면)
> 		deque에 거리 집어넣음
> 	else
> 		deque에 맨 뒤부터의 거리 넣음
> 	현재 정보 multiset과 배열에 넣음
> } 
> ```
> 내 생각에는 multiset에서 현재보다 작은 원소 찾는게 set을 다 도는 것보다는 시간이 단축되었다지만, 큰 수의 경우에는 원소의 개수만큼 돌기 때문에 여기서 시간이 많이 드는게 아닌가 싶다.
>
> 💬 
>
> 빠를 것 같은 자료구조로 난리난리를 쳤는데 알고보니 그냥 이중 포문으로 풀 수 있는 문제였다 ;; 허무하군,,
>
> 그리고 스택으로도 푸는 방법이 있다. 이건 생각도 못했다
>
> 

- [ ] **소수 찾기 (programmers level 2)**

> 21.01.07 **실패**
>
> 40분 잡고 풀었는데 일단 코드까지 어떻게 쓰긴 했지만, 제대로 안돌아가는 것 같다.
>
> 생각한 알고리즘은 다음과 같다.
>
> 1. 1 ~ 10^(number의 개수) 까지 소수여부를 배열에 미리 계산해 놓는다. (에라토스테네스의 채 사용)
>
> 2. 재귀 함수를 이용하여, 입력된 제한 크기까지 숫자 조합을 만든다.
>
>    제한 크기는 1 ~ number의 개수이다.
>
> 3. 만들어진 숫자 조합에서 next_permutation을 이용해 모든 순서를 생성해보고, 해당 순서로 만들어진 숫자가 소수인지 판단.
>
> 💬 
>
> [이 블로그](https://intaehwang.tistory.com/11)의 풀이를 보면 다음과 같이 풀이하였다.
>
> > 1. permutation을 이용하여 모든 경우를 구한다
> > 2. vector의 erase와 unique를 이용하여 중복된 vector 값을 제외한다.
> > 3. 주어진 vector 값의 소수 여부를 확인한다.
>
> 여기서 주안점은 숫자의 개수가 최대 7개 주어지기 때문에 7! = 5040이라는 적은 숫자이므로 permutation으로 죄다 돌면서 경우가 되는 ''숫자''만 미리 구해 놓는 것이다.  
> (나는 permutation을 썼지만 input size에 대해서는 깊게 생각을 안했다. 괄호 추가하기에서 했던 것과 같은 실수를 했다. 반성 또 반성)
>
> 그 다음에 중복되는 값을 제거하고 
> (이 기법도 알기는 하지만 익숙하지 않으므로 잘 외워놓아야겠다.)
>
> ``` c++
> sort(v.begin(), v.end());
> v.erase(unique(v.begin(), v.end()), v.end());
> ```
>
> 그 다음에 벡터에 있는 모든 값에 대해 소수인지 아닌지 확인한 것이다. 
> (굳이 숫자 사이즈 내의 모든 값을 다 소수판별 해놓을 필요가 전혀 없었다. 차라리 그때 그때 소수인지 확인해도 문제가 없었다. 왜냐면 사이즈가 작기 때문이지!!!!!! 좀 헛짓거리 줄이고 코테는 코테처럼 플젝은 플젝처럼 잘 해야할텐데...)

- [ ] **가장 큰 수**

> 21.01.07 **실패**
>
> 시간 오래 썼는데도 내가 원하는 대로 작동을 안한다. 
> 연이은 실패에 좌절감이 들지만,,,, 그냥 하루하루 배우는걸 목표로 삼아야지!!!! 
>
> 처음 생각한 알고리즘은 vector에 숫자를 문자열로 넣은 후 정렬을 하는데, 정렬함수 내의 알고리즘은 다음과 같이 썼다.
>
> 1. 작은 크기의 문자열 길이 기준으로 먼저 비교를 하고 사전식으로 리턴
> 2. 만약 작은 크기 문자열에서 글자가 다 같다면, 큰 크기 문자열의 바로 다음 글자와 맨 앞 글자를 비교한다. 
>
> 💬 
>
> 뭔가 알겠긴한데 안풀리는 이상한 빡치는 문제였다 
>
> string의 >, < 비교는 사전순으로 되며, 0이 맨 앞에 있는 경우에는 모든 수가 0이라는 뜻이므로 0 하나만 반환해야 한다. 

- [ ] **큰 수 만들기**

> 21.01.08 **실패**
>
> 그리디 문제 발상이 너무 어렵다 날잡아서 그리디 문제만 조져야겠다. 이번 문제에서는 number의 개수가 최대 1,000,000자리이기 때문에 완전탐색하면 시간 터질 것이 농후하다. 사실 문제 분류에서 그리디라고 힌트를 줬는데, 계속 고민해도 모르겠어가지고 포기했다.
>
> 내가 처음에 생각한 알고리즘은 다음과 같다.
>
> 1. 주어진 숫자 내에서 가장 작은 숫자 k개를 뽑아낸다. (중복 허용)
> 2. 숫자 맨 앞에서부터 시작해서 해당 숫자가 가장 작은 숫자내에 있으면 패스, 없으면 넣는다.
>
> 그런데 이렇게 하면 앞에 있는 숫자가 작은숫자에 포함되지 않는데, 큰 배열을 만들지도 않는 경우 망한다. 
>
> 💬 
>
> 앞에서부터 가장 큰 값을 찾는데, 이 때 왜 i+k까지인지 아직 이해가 잘 안된다
>
> [스택으로 푸는 풀이](https://devje8.tistory.com/4)도 있는데 좋은 발상인 것 같다.

- [ ] **조이 스틱**

> 21.01.09 **성공**
>
> 다른 사람의 코드를 구경하다가 내가 생각했던 원리와 같지만 훨씬 간결하게 표현한 코드가 있어 기록하려 한다.
>
> 목적은 무엇이냐면 name이라는 string 안에서 가장 긴 연속되는 'A' 길이에 대해 움직임 횟수를 찾는 것이다. 나는 이전 글자를 저장하고 다음 글자에서 매번 조건문을 확인하여 'A'의 개수를 확인 및 인덱스를 저장하였다. 그리고 반복문을 모두 돈 후 'A' 최대 배열 인덱스에 대한 최소 움직임 횟수를 구하였다. 근데 이 코드는, 'A' 배열을 한번에 찾고 거기서 바로 움직임 최소 횟수를 구해서 갱신하는 것이다. 
>
> <u>*나의 코드*</u>
>
> ```c++
> // 목적 : 전부 다 돌면서 최대 A 연속배열을 다 구한 후 최소 움직임 횟수 찾기
> int aCount = 0, aMaxCount = 0;
> char prev = name[0];
> int maxA[2];
> vector<int> Aindex;
> if (prev == 'A') {
>     aCount++;
>     Aindex.push_back(0);
> }
> for (int i = 1; i < name.size(); i++) {
>     if (prev == 'A') {
>         if (name[i] == 'A') {
>             aCount++;
>             Aindex.push_back(i);
>         }
>         else {
>             if (aMaxCount < aCount) {
>                 aMaxCount = aCount;
>                 maxA[0] = Aindex.front();
>                 maxA[1] = Aindex.back();
>             }
>             aCount = 0;
>             Aindex.clear();
>         }
>     }
>     else {
>         if (name[i] == 'A') {
>             aCount = 1;
>             Aindex.push_back(i);
>         }
>     }
>     prev = name[i];
> }
> if (prev == 'A' && aMaxCount < aCount) {
>     aMaxCount = aCount;
>     maxA[0] = Aindex.front();
>     maxA[1] = Aindex.back();
> }
> int backwards = name.size() - maxA[1] + 2 * maxA[0] - 3,
>     forwards = name.size() - 1;
> answer += forwards < backwards ? forwards : backwards;
> ```
>
> <u>*훨씬 간결한 코드*</u>
>
> ```c++
> int len = name.length();
> int left_right = len - 1;
> for (int i = 0; i < len; ++i) {
>    int next_i = i + 1;
>    while (next_i < len && name[next_i] == 'A') // 'A'연속 배열 한번에 구하기
>        next_i++;
>    left_right = min(left_right, i + len - next_i + min(i, len - next_i));
>     // 최소 움직임 횟수 구하기
> }
> ```
>
> 움직임 최소 횟수를 구하는 코드가 처음에는 이해가 잘 안됬다.
>
> ` i + len - next_i + min(i, len - next_i)` 
>
> 근데 왼쪽 들렸다 오는게 아니라 오른쪽 왕복을 하고 왼쪽은 편도로 가는게 빠른 경우도 있겠구나 라는 것을 깨달음 🤦🏻‍♀️

- [ ] **H-index**

> 21.01.09 **성공**
>
> 조금 더 디테일하게 값을 따져서 수식을 세우지 않아서 좀 시간 낭비를 했다.
>
> 인용 횟수를 정렬한 후, 인용 횟수보다 해당 인용 횟수 이상의 편수가 작거나 같으면 탈출하도록 조건을 짰는데, 작은 경우에 따져야 할 것이 추가로 있었다. 다시 말해서 인용 횟수가 해당 인용 횟수 이상의 편수보다 작거나 같을때는 단순히 그 직전 인용 횟수나 해당 편수가 답이 되는 것이 아니라, 그 두 값의 최댓값이 답이 되는 것이었다. 코드로 보면 이렇다.
>
> ```c++
> sort(citations.begin(), citations.end());
> for (int i = 0; i < citations.size(); i++) {
>     if (citations[i] == citations.size() - i) {
>         answer = citations[i]; break;
>     }
>     else if (citations[i] > citations.size() - i) {
>         answer = max(citations[i - 1], (int)citations.size() - i);
>         // 이 부분에서 두 값의 최대값을 구해야 했다.
>         break;
>     }
> }
> ```
>

- [ ] **위장**

> 21.01.09 
>
> 재귀를 구현하는게 좀 뻑뻑해졌다 다시 옛날에 풀어봤던 것들 좀 찾아서 익숙해져야겠다.

- [ ] **7579 앱**

> 21.01.13 **실패**
>
> 11053 가장 긴 증가하는 부분 수열 문제와 유사한 논리로 풀어보았다. 그런데 99%에서 틀려서 논리가 틀린 것은 아닌 것 같지만 엣지 케이스를 찾을 수 없어서 다시 구상을 했다.
>
> 문제 정의까지는 된 것 같은데 ("M 바이트 확보를 위해 필요한 앱 활성화의 최소 비용") DP 문제 쪼개기 발상이 잘 안된당. cost 낮은 순으로 해야 할지, 용량 대비 cost 낮은 순으로 해야 할 지 용량 큰 순으로 정렬해야 할지 모르겠고, 그 다음에 관계식을 어떻게 세울 지 잘 감이 안온당. 
>
> 냅색 스타일인가 했는데, M의 값이 너무 커서 배열을 만드는게 쉽지 않을 것 같고, 넣거나/안넣거나로 모든 원소를 돌게 되면 2^N이 되어 버려서 안된당.
>
> 💬 
>
> 찾아보니 냅색 스타일 문제는 맞는데, M을 이용해서 배열을 만드는게 아니라 cost 를 이용해서 배열을 만드는 거였다.
>
> 메모리는 초과를 해도되고 안해도 되기 때문에 메모리 기준으로 비용을 잡는 것이 아니라, 비용 기준으로 메모리를 잡는 것이 좋은듯. 그리고 다시 보니까 그냥 문제 자체를 정의로 잡았구나.
>
> 배열을 뒤에서부터 채워서 되는 것도 헷갈리고 그냥 문제를 많이 풀어서 이 감각을 익혀야 겠다 ㅠㅠㅠㅠ

- [ ] **2878 캔디캔디**

> 21.01.18 **실패**
>
> 그리디 너무 발상이 어렵다. "뭐랄까 숫자를 이렇게 깎고 대충 차이를 최소화 시키면 될 것 같은데" 그걸 수식으로 구현하고 풀어내고 그 정당성을 증명하는 게 너무 어렵다.
>
> 이 문제도 정렬하고, 주어진 사탕 개수를 요래조래 빼는것까지는 생각했는데, 처음에는 pivot을 차례 차례 잡고 그 앞에 있는 애들을 다 가지치기 하듯이 깎아주도록 풀었다. 근데 이 문제는 O(N^2) 나오니까 안되고, 그리디로 풀려면 분명히 앞에서부터 차례차례 딱딱 쳐내서 O(N)가 나와야 할 테고, 그러려면 미리 어떤 정보가 필요할 텐데 그거는 뭔가 현재 요구 사탕의 총합과 가용한 사탕의 개수가 될 것 같았다. 그치만 결국 그걸 구하는 방법은 생각하지 못했다. 
>
> 💬 
>
> 작은 순으로 정렬하고, 못주는 사탕을 분배하되, 최대한 평평하게 분배한것과 요구하는 사탕의 개수를 비교해서 작은 애를 선택하도록 만들면 풀리는 문제였다.

- [ ] **10775 공항**

> 21.01.18 **실패**
>
> 일단 매 공항마다 가능한 게이트를 돌게 되면 시간초과가 난다. 띠용 그냥 2878번 문제처럼 푸는 건 줄 알았는데 유니온 파인드 자료구조를 쓰는 문제다. 문제를 계속 선형적으로만 인식하고 있었는데 그래프의 관점에서 푸는 연습도 중요한 것 같다.
>
> 유니온 파인드, 우선순위 큐 등의 ''자료구조''는 단독으로 쓰이는 문제가 별로 없지만, 어떤 알고리즘을 구현하기 위해 필수적으로 써야 하는 기반이 된다. 자료구조의 본질은 어떤 작업을 효율적으로 처리하기 위해 존재하는 것이다. 이를 잘 기억해두자.

- [ ] **11085 군사 이동**

> 21.01.21 **실패**
>
> 일단 처음에 문제 이해를 잘못했다. *"경로 상에 있는 길 중 너비가 가장 좁은 길의 너비를 최대화하는 경로를 택했습니다."*라는 말이 당최 무슨 말인가 했더니 시작 위치에서 도착 위치로 가는 경로가 여러개 있을 텐데, 그 경로에 있는 각자의 최소 너비가 가장 큰 경로의 최소 너비를 찾는 것이다. 
>
> 코드는 마치 다익스트라처럼 생겼으나 약간 다른데, 어떤 점에서 다르냐면, 정점을 하나 뽑고 다음 경로로 갈 때 최솟값을 계속 가지고 간다. 그런데, priority queue를 사용했으므로 그 중에서 작은건 나중에 뽑힌다. 